
#include <stdlib.h>
#include <stdio.h>
#include "RPC_app.h"    // header file generated by MIDL compiler

void Upload(IN RPC_BINDING_HANDLE hBinding, unsigned char* filename, byte* data, long long len)
{
    FILE* f = fopen(filename, "wb+");
    puts(filename);
    if (!f) {
        printf("Upload: failed to open file %s\n", filename);
        return;
    }
    size_t written = fwrite(data, 1, len, f);
    fclose(f);
}

long long get_file_len(IN RPC_BINDING_HANDLE hBinding, unsigned char* fileway) {
    FILE* f = fopen(fileway, "rb");
    if (f == NULL) {
        puts("ERROR: source file == NULL");
        return -1;
    }
    // перемещаем указатель в конец и считываем значение
    fseek(f, 0, SEEK_END);
    return ftell(f);
}

void Download(handle_t hBinding, char* filename, byte* data, unsigned long len) {
    FILE* f = fopen(filename, "rb");
    if (!f) return;
    fread(data, 1, len, f);  // читаем не больше len байт
    fclose(f);
    printf("Download: sent %lu bytes from %s\n", len, filename);
}

void Shutdown(IN RPC_BINDING_HANDLE hBinding)
{
    RPC_STATUS status;

    printf_s("Calling RpcMgmtStopServerListening\n");
    status = RpcMgmtStopServerListening(NULL);
    printf_s("RpcMgmtStopServerListening returned: 0x%x\n", status);
    if (status) {
        exit(status);
    }

    printf_s("Calling RpcServerUnregisterIf\n");
    status = RpcServerUnregisterIf(NULL, NULL, FALSE);
    printf_s("RpcServerUnregisterIf returned 0x%x\n", status);
    if (status) {
        exit(status);
    }
}





/*
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "RPC_app.h"   // сгенерируется midl'ом

// MIDL memory routines (обычно нужны)
void* __RPC_USER midl_user_allocate(size_t size)
{
    return malloc(size);
}
void __RPC_USER midl_user_free(void* p)
{
    free(p);
}


 // * Upload:
 // *  - перезаписывает файл (CREATE_ALWAYS) и записывает len байт из data
 
void Upload(
    handle_t hBinding,
    char* filename,
    byte* data,
    unsigned long len
)
{
    DWORD written = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    if (filename == NULL || data == NULL) {
        RpcRaiseException(ERROR_INVALID_PARAMETER);
        return;
    }

    // В продакшене: проверяй путь (whitelist, длину, запрещённые символы и т.д.)
    hFile = CreateFileA(
        filename,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_ALWAYS,         // перезаписать/создать заново
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (hFile == INVALID_HANDLE_VALUE) {
        DWORD err = GetLastError();
        printf("[Server] Upload: CreateFileA failed (%u) for \"%s\"\n", err, filename);
        RpcRaiseException((RPC_STATUS)err);
        return;
    }

    if (len > 0) {
        if (!WriteFile(hFile, data, (DWORD)len, &written, NULL) || written != (DWORD)len) {
            DWORD err = GetLastError();
            CloseHandle(hFile);
            printf("[Server] Upload: WriteFile failed (%u)\n", err);
            RpcRaiseException((RPC_STATUS)err);
            return;
        }
    }

    CloseHandle(hFile);
    printf("[Server] Upload OK: \"%s\" (%u bytes)\n", filename, len);
}


 // * Download:
 // *  - читает файл и записывает не более len байт в буфер data,
 // *    если файл меньше len — запишет только прочитанные байты.
 // *  - клиент НЕ узнаёт реальный прочитанный размер (если нужен - добавь out param actualSize)

void Download(
    handle_t hBinding,
    char* filename,
    byte* data,
    unsigned long len
)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD toRead, readBytes;

    if (filename == NULL || data == NULL) {
        RpcRaiseException(ERROR_INVALID_PARAMETER);
        return;
    }

    hFile = CreateFileA(
        filename,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (hFile == INVALID_HANDLE_VALUE) {
        DWORD err = GetLastError();
        printf("[Server] Download: CreateFileA failed (%u) for \"%s\"\n", err, filename);
        RpcRaiseException((RPC_STATUS)err);
        return;
    }

    if (len == 0) {
        // Нечего записывать в буфер
        CloseHandle(hFile);
        return;
    }

    toRead = (len > 0xFFFFFFFFu) ? 0xFFFFFFFFu : (DWORD)len;
    if (!ReadFile(hFile, data, toRead, &readBytes, NULL)) {
        DWORD err = GetLastError();
        CloseHandle(hFile);
        printf("[Server] Download: ReadFile failed (%u)\n", err);
        RpcRaiseException((RPC_STATUS)err);
        return;
    }

    // Если прочитано меньше, чем len, оставшееся в буфере остаётся как есть.
    CloseHandle(hFile);
    printf("[Server] Download OK: \"%s\" -> %u bytes\n", filename, readBytes);
}


void DeleteFile_RPC(
    handle_t hBinding,
    char* filename
)
{
    BOOL ok;
    if (filename == NULL) {
        RpcRaiseException(ERROR_INVALID_PARAMETER);
        return;
    }

    ok = DeleteFileA(filename);
    if (!ok) {
        DWORD err = GetLastError();
        printf("[Server] DeleteFile failed (%u) for \"%s\"\n", err, filename);
        RpcRaiseException((RPC_STATUS)err);
        return;
    }
    printf("[Server] DeleteFile OK: \"%s\"\n", filename);
}

/*
 * Если твой IDL использовал точные имена Upload/Download/DeleteFile,
 * убедись, что prototype совпадает с тем, что генерирует MIDL.
 * В примере выше я дал DeleteFile_RPC чтобы избежать коллизии с
 * DeleteFileA/макросами; если в HELLO.h у тебя имя DeleteFile,
 * переименуй функцию обратно в DeleteFile.
 */
