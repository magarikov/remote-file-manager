
#define _CRT_SECURE_NO_WARNINGS
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include "RPC_app.h"    // header file generated by MIDL compiler


char* append(char* str1, const char* str2) {
    int i = 0;
    int j = 0;
    while ((str1)[i] != 0) i++;
    while (str2[j] != 0) {
        (str1)[i + j] = str2[j];
        j++;
    }
    str1[i + j] = 0;
}

char* UNC_to_DOS(char* str)
{
    char* output = calloc(512, 1);
    int i = 4;
    while (str[i] != '\\') i++;
    if (((str[i + 1] == 'C') || (str[i + 1] == 'D') || (str[i + 1] == 'E')) && ((str[i + 2] == '\\'))) {
        output[0] = str[i + 1]; // буква диска
        output[1] = ':';
        append(output, &(str[i + 2])); // путь к файлу
    }
    else append(output, &(str[i + 1])); // путь к файлу
    return output;
}



char* DOS_to_UNC(char* src) {

    char* output = calloc(512, 1);
    append(output, "\\\\ip\\");

    int i = 0;
    if (src[1] == ':') {
        output[5] = src[0];
        output[6] = '\\';
        while (src[i] != ':') i++;
        i += 2;
    }


    append(output, &src[i]);

    while (output[i] != 0) {
        if (output[i] == '/') output[i] = '\\';
        i++;
    }

    printf("%d\n", i);
    return output;
}



void upload_file(RPC_BINDING_HANDLE hBinding) {
    
    // считываем и преобразовываем путь
    char* fileway_src = calloc(512, 1); 
    printf("Input way to file on client PC: ");
    gets(fileway_src);
    fileway_src = UNC_to_DOS(fileway_src);

    
    char* fileway_dest = calloc(512, 1);
    printf("Input way to file on server: ");
    gets(fileway_dest);
    fileway_dest = UNC_to_DOS(fileway_dest);
    puts(fileway_dest);

    FILE* f = fopen(fileway_src, "rb");
    if (f == NULL) {
        puts("ERROR: source file == NULL");
        return;
    }

    // перемещаем указатель в конец и считываем значение
    fseek(f, 0, SEEK_END);
    long size = ftell(f);

    // возвращаем указатель в начало
    fseek(f, 0, SEEK_SET);

    // выделяем память и отправляем
    byte* buffer = (byte*)malloc(size);
    fread(buffer, 1, size, f);
    fclose(f);

    Upload(hBinding, fileway_dest, buffer, (unsigned long)size);
    free(buffer);
    
}

void download_file(RPC_BINDING_HANDLE hBinding) {

    // считываем и преобразовываем путь
    char* fileway_src = calloc(512, 1);
    printf("Input way to file on server: ");
    gets(fileway_src);
    fileway_src = UNC_to_DOS(fileway_src);


    char* fileway_to_put = calloc(512, 1);
    printf("Input way to file on client PC: ");
    gets(fileway_to_put);
    fileway_to_put = UNC_to_DOS(fileway_to_put);


    // запрашиваем размер передаваемых данных
    unsigned long fileSize = 0;
    fileSize = get_file_len(hBinding, fileway_src);

    byte* recvBuf = (byte*)malloc(fileSize);
    Download(hBinding, fileway_src, recvBuf, fileSize);

    FILE* fout = fopen(fileway_to_put, "wb");
    fwrite(recvBuf, 1, fileSize, fout);
    fclose(fout);
    free(recvBuf);
}


void __cdecl main(int argc, char** argv)
{

    RPC_BINDING_HANDLE hBinding = NULL;
    RPC_STATUS status; // 0 - успех
    unsigned char* pszUuid = NULL; // UUID для endpoint (NULL означает отсутствие конкретного UUID — обычно не используется для простого клиента)
    unsigned char* pszProtocolSequence = "ncacn_ip_tcp";
    unsigned char* pszNetworkAddress = NULL; // Адрес сервера (IP или имя).
    unsigned char* pszEndpoint = "8765";
    unsigned char* pszSpn = NULL;
    unsigned char* pszOptions = NULL; // Дополнительные опции в строке подключения (например, ;tcp или специфичные параметры). Обычно NULL.
    unsigned char* pszStringBinding = NULL; // Итоговая строка подключения (string binding), которую заполнит RpcStringBindingCompose. Это выделяется API и её нужно освободить RpcStringFree.
    unsigned char* pszString = "hello, world"; // Может быть переопределена через -s
    RPC_SECURITY_QOS SecQos; // Структура, описывающая «качество обслуживания» безопасности RPC (QOS): версия, возможности, трекинг идентичности, уровень прав делегирования/внедрения идентификации (impersonation).
    unsigned long ulCode; // Вспомогательные переменные — ulCode для хранения кода исключения
    int i;
    

    // Use a convenience function to concatenate the elements of
    // the string binding into the proper sequence.

    // RpcBindingFromStringBinding создает binding-handle из строки привязки. 
    // Обычная сигнатура: RPC_STATUS RpcBindingFromStringBindingA(unsigned char *StringBinding, RPC_BINDING_HANDLE *Binding);. 
    // В MIDL-заголовке hello_v1_0_c_ifspec сгенерирован так, что его адрес используется как целевой binding-handle клиента 
    // (в клиентских stub'ах это — переменная, объявленная как RPC_BINDING_HANDLE hello_v1_0_c_ifspec; или похожая). 
    // После успешного вызова hello_v1_0_c_ifspec содержит handle, который будет передаваться в удалённые вызовы.
    status = RpcStringBindingCompose(pszUuid, // RpcStringBindingCompose — удобная утилита RPC API, которая поверхностно конкатенирует компоненты
        pszProtocolSequence,        //  (UUID, порядок протоколов, сетевой адрес, endpoint/порт, опции) в строку привязки формата "uuid:protseq:netaddr:endpoint[?options]".
        pszNetworkAddress,
        pszEndpoint,
        pszOptions,
        &pszStringBinding);
    printf_s("RpcStringBindingCompose returned 0x%x\n", status);
    printf_s("pszStringBinding = %s\n", pszStringBinding);
    if (status) {
        exit(status);
    }
    
    // Set the binding handle that will be used to bind to the server.
    // Получаем binding handle из строки привязки
    status = RpcBindingFromStringBinding(pszStringBinding,
        &hBinding);
    

    printf_s("RpcBindingFromStringBinding returned 0x%x\n", status);
    if (status) {
        exit(status);
    }
    

    RpcTryExcept{

        //upload_file(hBinding);
        download_file(hBinding);
        
        
        
    }
        RpcExcept((((RpcExceptionCode() != STATUS_ACCESS_VIOLATION) &&
            (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT) &&
            (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION) &&
            (RpcExceptionCode() != STATUS_BREAKPOINT) &&
            (RpcExceptionCode() != STATUS_STACK_OVERFLOW) &&
            (RpcExceptionCode() != STATUS_IN_PAGE_ERROR) &&
            (RpcExceptionCode() != STATUS_GUARD_PAGE_VIOLATION)
            )
            ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)) {
        ulCode = RpcExceptionCode();
        printf_s("Runtime reported exception 0x%lx = %ld\n", ulCode, ulCode);
        

    }
    RpcEndExcept

        //  The calls to the remote procedures are complete.
        //  Free the string and the binding handle
        status = RpcStringFree(&pszStringBinding);  // remote calls done; unbind
    printf_s("RpcStringFree returned 0x%x\n", status);
    if (status) {
        exit(status);
    }

    status = RpcBindingFree(&hBinding);  // remote calls done; unbind
    printf_s("RpcBindingFree returned 0x%x\n", status);
    if (status) {
        exit(status);
    }

    exit(0);

}  // end main()


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void  __RPC_FAR* __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR* ptr)
{
    free(ptr);
}





/*
// RPC_client.c
#include <windows.h>
#include <stdio.h>
#include "RPC_app.h"   // сгенерированный midl'ом заголовок

int main(void)
{
    
    RPC_STATUS status;
    RPC_BINDING_HANDLE hBinding = NULL;
    unsigned char* stringBinding = NULL;

    // 1. Составляем строку биндинга (ncacn_ip_tcp, localhost:9000)
    status = RpcStringBindingComposeA(
        NULL,                      // obj UUID (не используется)
        (unsigned char*)"ncacn_ip_tcp", // протокол
        (unsigned char*)"localhost",    // адрес сервера (можно IP или hostname)
        (unsigned char*)"9000",         // endpoint (порт)
        NULL,                      // опции
        &stringBinding);

    if (status) {
        printf("RpcStringBindingCompose failed: %u\n", status);
        return 1;
    }

    // 2. Превращаем строку биндинга в handle
    status = RpcBindingFromStringBindingA(stringBinding, &hBinding);
    if (status) {
        printf("RpcBindingFromStringBinding failed: %u\n", status);
        RpcStringFreeA(&stringBinding);
        return 1;
    }

    RpcStringFreeA(&stringBinding);

    // ====== Пример вызова Upload ======
    {
        puts("1");
        const char* filename = "server_test.txt";
        const char* data = "Hello from client via RPC!";
        unsigned int len = (unsigned int)strlen(data);

        __try {
            Upload(hBinding, (wchar_t*)L"server_test.txt",
                (byte*)data, len);
            printf("Upload OK\n");
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            printf("Upload failed. RPC Exception code: %u\n",
                GetExceptionCode());
        }
        puts("2");
    }

    // ====== Пример вызова Download ======
    {
        unsigned char buffer[1024];
        memset(buffer, 0, sizeof(buffer));
        puts("3");
        __try {
            Download(hBinding,
                (wchar_t*)L"server_test.txt",
                buffer, sizeof(buffer));

            printf("Download OK. Data: \"%s\"\n", buffer);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            printf("Download failed. RPC Exception code: %u\n",
                GetExceptionCode());
        }
        puts("4");
    }

    // 3. Освобождаем биндинг
    status = RpcBindingFree(&hBinding);
    if (status) {
        printf("RpcBindingFree failed: %u\n", status);
    }
    puts("5");
    return 0;
}

// ======== RPC runtime requires these ========
void __RPC_FAR* __RPC_USER midl_user_allocate(size_t len) {
    return malloc(len);
}
void __RPC_USER midl_user_free(void __RPC_FAR* ptr) {
    free(ptr);
}
*/